

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>基础概念 &mdash; 以太坊的指南针 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="语法进阶" href="levelup.html" />
    <link rel="prev" title="第 8 章 Solidity语法练习" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> 以太坊的指南针
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../howto.html">如何学习这本书</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ch1/index.html">第 1 章 以太坊：一台全球计算机</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch1/born.html">简史</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/progress.html">发展阶段</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch1/highlight.html">以太坊的特色</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ch2/index.html">第 2 章 账户是什么</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch2/basic.html">小白基础知识问答</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch2/basic.html#id2">我的以太币记录在哪里？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/basic.html#id3">我的以太币余额如何变化？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/basic.html#id4">什么是区块？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/basic.html#id5">区块和状态的关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/basic.html#id6">“巨大的账本”</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/basic.html#id7">我如何参与以太坊？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/basic.html#id8">我如何与其他人同步账本？</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/account.html">账户探秘</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch2/account.html#id2">账户与账户状态</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/account.html#id3">账户状态的内涵</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../ch2/account.html#id4">已执行交易总数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../ch2/account.html#id5">持币数量</a></li>
<li class="toctree-l4"><a class="reference internal" href="../ch2/account.html#id6">存储区的哈希值</a></li>
<li class="toctree-l4"><a class="reference internal" href="../ch2/account.html#id7">代码区的哈希值</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/account.html#app">没有钱包App, 如何生成账户？</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch2/account.html#id11">智能合约地址的生成</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/interval.html">扩展阅读</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/keystore.html">资料篇：Keystore 与私钥保存</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/app.html">资料篇：常用钱包 App</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch2/eip55.html">资料篇：EIP-55 格式的账户地址</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ch3/index.html">第 3 章 交易是驱动力</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch3/how.html">交易的发送</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch3/how.html#id2">交易与消息的区别</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch3/how.html#id3">交易的特性是什么？</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/what.html">交易的样子</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/life.html">交易的生命周期</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/interval.html">扩展阅读</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/pow.html">资料篇：共识与工作量证明</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch3/pow.html#pow">比特币的PoW机制（简单版）</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch3/pow.html#id2">比特币算力的中心化问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch3/pow.html#pow-pos">以太坊的Pow/Pos机制</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch3/dig.html">资料篇：矿工与挖矿奖励</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ch4/index.html">第 4 章 数据结构</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch4/radix.html">Radix树</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/merkle.html">Merkle树和 Merkle证明</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/mpt.html">Merkle Patricia树</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/rlp.html">RLP编码</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch4/rlp.html#id1">RLP字符/字符串编码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch4/rlp.html#id2">RLP字符/字符串解码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch4/rlp.html#id3">RLP数组编码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch4/rlp.html#id4">RLP数组解码</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/interval.html">扩展阅读</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/stateroot.html">资料篇：状态树 (以及存储树）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/transroot.html">资料篇：交易树</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/receiptroot.html">资料篇：收据树</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch4/block.html">资料篇：区块</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ch5/index.html">第 5 章 构建一条以太坊私链</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch5/install.html">安装</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/geth.html">Geth客户端的结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/build.html">启动一条以太坊私链</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/coinbase.html">接收挖矿奖励</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch5/transfer.html">转账与收款</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ch6/index.html">第 6 章 手把手教你部署智能合约</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch6/what.html">什么是智能合约？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch6/install.html">安装编译器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch6/compile.html">Solc编译智能合约</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch6/prepare.html">智能合约发布准备</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch6/deploy.html">部署智能合约</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch6/call.html">调用智能合约</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ch7/index.html">第 7 章 以太坊虚拟机探秘</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch7/result.html">虚拟机的执行结果</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/resource.html">虚拟机的执行资源</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/call.html">合约调用合约?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/io.html">虚拟机的输入输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/gas.html">Gas 花费与退回</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch7/instructions.html">虚拟机指令集</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第 8 章 Solidity语法练习</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">基础概念</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">没有浮点数运算</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">合约基础</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">变量类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">运算符号</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct">结构体 Struct</a></li>
<li class="toctree-l3"><a class="reference internal" href="#array">数组array</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">函数申明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">类型转换与内置函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">合约与事件</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="levelup.html">语法进阶</a><ul>
<li class="toctree-l3"><a class="reference internal" href="levelup.html#map">数据结构：map</a></li>
<li class="toctree-l3"><a class="reference internal" href="levelup.html#msg-sender">环境变量：msg.sender</a></li>
<li class="toctree-l3"><a class="reference internal" href="levelup.html#requireassert">require还是assert?</a></li>
<li class="toctree-l3"><a class="reference internal" href="levelup.html#id2">继承和引入</a></li>
<li class="toctree-l3"><a class="reference internal" href="levelup.html#id3">省钱妙招：内存变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="levelup.html#id4">接口与合约调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="levelup.html#id5">多返回值</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="advanced.html">高级语法和概念</a><ul>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#contract">Contract 构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#ownable">Ownable控制</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#pausable">Pausable控制</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#struct">省钱妙招：struct 结构体</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#id2">时间单位表达</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#id3">带参数的函数修饰符</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#for">for 循环</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#payable">合约收款：payable修饰符</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html#transfer">支付费用：transfer方法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="summary.html">小结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ch9/index.html">第 9 章 Truffle合约开发实战</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch9/install.html">编译、测试工具安装</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch9/install.html#truffle">Truffle的安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/install.html#ganache">Ganache的安装</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/sample.html">Truffle启动样例项目</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch9/sample.html#id1">下载样例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/sample.html#id2">编译项目</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/sample.html#ganache">部署项目到 Ganache</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/sample.html#id3">测试项目</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/erc20.html">上手实践：ERC20合约</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch9/erc20.html#id1">新建项目目录</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/erc20.html#erc20-basic">ERC20 Basic合约接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/erc20.html#id2">ERC20 合约接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/erc20.html#safemath">SafeMath基础数学库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/erc20.html#cat">猫币：CAT数字资产合约</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch9/test.html">上手实践：ERC20合约测试</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch9/test.html#id1">准备工作</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/test.html#id2">测试辅助函数与库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/test.html#id3">测试代码分析</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch9/test.html#id4">测试运行与结果</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ch10/index.html">附录 有意思的冷知识</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../ch10/shortattack.html">短地址攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch10/block.html">比特币的区块</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch10/utxo.html">以太坊与比特币账户的区别</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch10/utxo.html#id2">隐私与安全性的比较</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch10/utxo.html#id3">数据体积与并发能力</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch10/utxo.html#id4">发送交易时对双花的处理</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ch10/triangle.html">“不可能的三角”问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ch10/ethash.html">ETHASH 挖矿算法</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../ch10/ethash.html#ethashpow">ETHASH和比特币PoW的异同</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch10/ethash.html#id1">ETHASH的设计目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch10/ethash.html#id2">ETHASH的挖矿运行总流程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ch10/ethash.html#id3">ETHASH算法源代码解读</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">以太坊的指南针</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          



















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">第 8 章 Solidity语法练习</a> &raquo;</li>
        
      <li>基础概念</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <!-- User defined GitHub URL -->
              <a href="https://github.com/laalaguer/ethereum-compass/blob/master/ch8/basic.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>基础概念<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>本小节将重点介绍Solidity语法的基础，从最基本的合约结构和函数变量讲起。知识点都不复杂，读者只要带着纸笔填写练习就好，为后面的章节学习打下良好的基础。</p>
<div class="section" id="id2">
<h2>没有浮点数运算<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>以太坊虚拟机给程序员的第一个惊(jing)喜(xia)就是： <strong>它不会浮点数运算</strong> ！诸如 1+2=3 的运算它是绰绰有余的，你也可以放入 2*100=200 做乘法运算。</p>
<p>但很不幸的是，没有一个变量可以表示 <code class="docutils literal notranslate"><span class="pre">3.14</span></code> 这样的数字，因为虚拟机根本不支持浮点数运算。</p>
<p>为了弥补这个缺陷，如何表示带小数的数字呢？以太坊将自身的数切分为最小 <code class="docutils literal notranslate"><span class="pre">18</span></code> 位，我们称为 <code class="docutils literal notranslate"><span class="pre">wei</span></code> ，任何数字都是wei的整数倍。具体的换算表如下。</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="17%" />
<col width="47%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>单位</td>
<td>wei 值</td>
<td>wei</td>
</tr>
<tr class="row-even"><td>wei</td>
<td>1 wei</td>
<td>1</td>
</tr>
<tr class="row-odd"><td>kwei (babbage)</td>
<td>1e3 wei</td>
<td>1,000</td>
</tr>
<tr class="row-even"><td>mwei (lovelace)</td>
<td>1e6 wei</td>
<td>1,000,000</td>
</tr>
<tr class="row-odd"><td>gwei (shannon)</td>
<td>1e9 wei</td>
<td>1,000,000,000</td>
</tr>
<tr class="row-even"><td>microether (szabo)</td>
<td>1e12 wei</td>
<td>1,000,000,000,000</td>
</tr>
<tr class="row-odd"><td>milliether (finney)</td>
<td>1e15 wei</td>
<td>1,000,000,000,000,000</td>
</tr>
<tr class="row-even"><td>ether</td>
<td>1e18 wei</td>
<td>1,000,000,000,000,000,000</td>
</tr>
</tbody>
</table>
<p>请不要担心，上表看上去这么复杂，wei、kwei、mwei、gwei 算比例让人头晕，其实最重要的仅有最后一条，</p>
<p class="centered">
<strong><span class="math notranslate nohighlight">\(1 {ether} = 10^{18} {wei}\)</span></strong></p><p>也就是说，当我们说1以太币的时候，在运行智能合约的虚拟机眼中，是相当于 1 x <span class="math notranslate nohighlight">\(10^{18}\)</span> 的一个数。平时我们会用库函数来辅助我们构建数字，不用担心漏数了 <code class="docutils literal notranslate"><span class="pre">0</span></code> 的情况。</p>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请填写以下的等式，让 wei 和 ether 对应起来：</p>
<div class="last highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="m">1</span> <span class="nv">ether</span> <span class="o">=</span> ________________ wei

<span class="m">314</span>.159 <span class="nv">ether</span> <span class="o">=</span> ____________ wei

<span class="m">0</span>.156 <span class="nv">ether</span> <span class="o">=</span> ____________ wei
</pre></div>
</div>
</div>
</div>
<div class="section" id="id3">
<h2>合约基础<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>所有智能合约的代码都是包含在一组 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 包含的 <code class="docutils literal notranslate"><span class="pre">contract</span></code> 关键字里的，没有例外。</p>
<p>合约是以太坊合约的基本”砖块”：所有的函数和变量都包含在这组花括号内，所有程序都是合约砖块的堆砌和组织。例如下方的 Hello 合约。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="n">Hello</span> <span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
<p>预编译指令 <code class="docutils literal notranslate"><span class="pre">pragma</span></code> 也是合约的基础，它比较特殊，每份合约文件申明在开头，颇有 C/C++ 的风范。</p>
<p>pragma 指定了该使用哪个以太坊字节码编译器来编译这份源代码。
以太坊的编译器迭代了多个版本，指定一个没有bug的编译器也是一种技巧保障安全。</p>
<p>预编译指令非常简单，包含了想采用的编译器的版本，例如下方代码指定了 <code class="docutils literal notranslate"><span class="pre">0.4.24</span></code> 版本。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">pragma solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">24</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请填充下方的空白处，创建一份智能合约，将其命名为汽车工厂CarFactory， 指定编译器版本为0.4.24：</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">pragma solidity</span> <span class="o">^</span><span class="n">_____</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">______</span> <span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id4">
<h2>变量类型<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>智能合约的变量分为两种，存在区块链上的和不存在区块链上的。存在区块链上的我们称为状态变量（state variable）。这类变量将永久记录在区块链上，写入读取它们就仿佛操作一个数据库一样，修改和赋值都会造成巨额的开销。不存在于区块链上的变量则是程序中的内存变量（memory variable），程序运行完毕就从内存中释放，相对开销较小。</p>
<p>例如将一个值100复制给一个状态变量 amount。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="n">Example</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//永久记录于区块链上</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">uint</span></code> 变量类型即为unsigned integer的缩写，学过C/C++的同学一定感到很熟悉，该类型存储了一个非负的整数。实际上Solidity里面有多种位长的 uint 可以供我们选择，例如 <code class="docutils literal notranslate"><span class="pre">uint8、uint32、uint256</span></code> 等，实际使用中 <code class="docutils literal notranslate"><span class="pre">uinit256</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uint</span></code> 是等价语法。</p>
<p>256位足够存储我们上述所提到的 10^18 wei 的空间还绰绰有余。</p>
<p>在本教程大部分代码里，将不区别 uint256 和 uint；在能用 uint 的地方尽量使用 uint 来保持数字的容量足够大。</p>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请在下面的空白处填写，让colorDigits 等于16，我们日后用它记录汽车颜色:</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">pragma solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">24</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">CarFactory</span> <span class="p">{</span>
    <span class="c1">//这里填写</span>
    <span class="kt">uint</span> <span class="n">colorDigits</span> <span class="o">=</span> <span class="n">____</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2>运算符号<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Solidity 里面的数学运算都是普通的数学运算。加减乘除都与惯常理解一致。唯一的特殊点在于指数运算，例如10^18表示为如下的形式。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">18</span>
</pre></div>
</div>
<p>其余的算术运算如下。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 8</span>
<span class="kt">uint</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 6</span>
<span class="kt">uint</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 30</span>
<span class="kt">uint</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span> <span class="o">%</span> <span class="mi">7</span> <span class="c1">// 7 * 4 = 28, 余数为 2</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请在下面空白处填写，让 colorModulus 等于10的 colorDigits次方，这样我们每次做除法的时候，可以保证余数的不超过colorDigits 位。</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">pragma solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">24</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">CarFactory</span> <span class="p">{</span>

    <span class="kt">uint</span> <span class="n">colorDigits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="c1">//这里填写</span>
    <span class="kt">uint</span> <span class="n">colorModulus</span> <span class="o">=</span> <span class="n">____</span> <span class="o">**</span> <span class="n">___</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="struct">
<h2>结构体 Struct<a class="headerlink" href="#struct" title="Permalink to this headline">¶</a></h2>
<p>有时候 Solidity 提供的基本数字类型、文字类型并不能封装我们需要的数据结构，在面向对象的编程语言中，由于函数返回只能返回一个值，所以对返回结果进行了大量的封装、解封装的操作。在Solidity中我们也可以封装数个基本类型为一个结构体，例如我们面对一个“人”对象的时候，可以将他的年龄和姓名封装入一个结构体中。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="n">Person</span> <span class="p">{</span>
  <span class="kt">uint16</span> <span class="n">age</span><span class="p">;</span> <span class="c1">//16位应该能涵盖大部分正常人类寿命</span>
  <span class="kt">string</span> <span class="n">name</span><span class="p">;</span> <span class="c1">// 例如 name = “Peter Wilson Jr.”</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上述结构体struct是Solidity语言中预置的关键字，帮助我们将数个基本类型进行封装成一个通用的结构体。结构体struct在高级用法中并不只是封装了数据这么简单，它还能作为编译器优化的手段来节约代码运行、存储时候的gas花费。
这里我们介绍一个新类型 <code class="docutils literal notranslate"><span class="pre">string</span></code> – <strong>任意长度</strong> 的字符串，每个字符是 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 类型的值。</p>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请在空白处填写，创建一个汽车结构体Car，Car拥有一个名称name和颜色color属性：</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="n">_____</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="n">___</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="n">___</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="array">
<h2>数组array<a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h2>
<p>当我们想创建同类型数据的集合的时候就用上了 array 数组。一个数组里面可以加入同类型的数据，哪怕是 struct 类型的数据都可以是数组的基本类型。例如下面的数组。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="kr">fixed</span><span class="p">;</span> <span class="c1">// 定长数组，只能包含3个元素，每个元素是 uint</span>
<span class="kt">string</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">stringArray</span><span class="p">;</span> <span class="c1">// 定长数组，只能包含10个元素， 每个元素是 string</span>
<span class="n">Person</span><span class="p">[]</span> <span class="n">dynamic</span><span class="p">;</span> <span class="c1">// 可变长数组，可持续增长，每个元素是 Person 结构体</span>
</pre></div>
</div>
<p>可变长数组给我们提供了一个机会，类似数据库，可以持续往这个“篮子”里面写入和读取数字，在写入读取的时候势必会有权限问题(可不可以被合约外访问到？)，我们采用 public关键字来修饰变量，让变量可以公开被合约外访问到，但该访问并不包含修改权限，仅仅包含了读取权限。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="n">Bike</span><span class="p">[]</span> <span class="k">public</span> <span class="n">bikes</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请创建一个可容纳Car类型的动态长度数组cars：</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">pragma solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">24</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">CarFactory</span> <span class="p">{</span>

    <span class="kt">uint</span> <span class="n">colorDigits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="n">colorModulus</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">colorDigits</span><span class="p">;</span>

    <span class="kd">struct</span> <span class="n">Car</span> <span class="p">{</span>
        <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">color</span><span class="p">;</span>
    <span class="p">}</span>

<span class="c1">// 这里填充</span>
<span class="n">____</span><span class="p">[]</span> <span class="k">public</span> <span class="n">____</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id6">
<h2>函数申明<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>一个智能合约的“能动”部分就是函数。函数承担了数据读取，数据修改，以及数据存储的触发。</p>
<p>智能合约并没有一个入口main函数来执行整个程序。</p>
<p>你可以把它类比为Web后端开发中为响应请求而写的一个一个 Request Handler，也可以理解为 Android 编程中为响应外部生命周期调用而存在的各个响应函数。</p>
<p>只要记住一个中心思想：智能合约的函数调用是“被动的”，需要外部主动来触发。</p>
<p>我们很容易构建一个函数，指定它的输入参数。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">drinkTea</span><span class="p">(</span><span class="kt">string</span> <span class="n">_name</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_amount</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">drinkTea</span><span class="p">(</span><span class="s">&quot;Lemon Tea&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</pre></div>
</div>
<p>上方我们申明了一个 <code class="docutils literal notranslate"><span class="pre">drinkTea</span></code> 函数，接收两个参数(一般函数参数用下划线_开头以区别于全局变量)，在调用时候采用数值直接填写方式调用即可。</p>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请在下方创建函数createCar, 并且该函数接受两个参数，_name (string 类型)和 _color( uint类型):</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">________</span> <span class="p">(</span><span class="n">_____</span> <span class="n">_name</span><span class="p">,</span> <span class="n">_____</span> <span class="n">_color</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<p>函数有了，我们接下来填充这个函数的代码，让它能够执行一定的任务。例如生成一些数据并且填充。在 Solidity 中，数据可以被组织进入数组 Array 中，而数据类型可以随意选择。例如我们之前提到的 Person 数据结构，我们基于它构建一个people数组。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="n">Person</span> <span class="p">{</span>
  <span class="kt">uint16</span> <span class="n">age</span><span class="p">;</span>
  <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Person</span><span class="p">[]</span> <span class="k">public</span> <span class="n">people</span><span class="p">;</span>
</pre></div>
</div>
<p>我们可以申明新的 Person 并且加入 people 里面，不断扩充这数组，例如我们创建Steve Jobs这人物并且填充入数组。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="n">Person</span> <span class="n">steve</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span> <span class="s">&quot;Steve Jobs&quot;</span><span class="p">);</span> <span class="c1">// 申明该人物</span>
<span class="n">people</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">steve</span><span class="p">);</span> <span class="c1">// 填充进入数组</span>
<span class="n">people</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span> <span class="s">&quot;Steve Jobs&quot;</span><span class="p">));</span><span class="c1">// 也可以简化为一行代码更紧凑</span>
</pre></div>
</div>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请填充我们的createCar函数，并且创建一个Car结构体加入已有的Car数组内。</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="n">Car</span><span class="p">[]</span> <span class="k">public</span> <span class="n">cars</span><span class="p">;</span>
<span class="kd">function</span> <span class="n">createCar</span><span class="p">(</span><span class="kt">string</span> <span class="n">_name</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_color</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">cars</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">_____</span> <span class="p">(</span><span class="n">_____</span><span class="p">,</span> <span class="n">______</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>很好，函数的介绍部分基本完成了。目前为止我们尚未接触到函数权限问题。作为语言间的对比，在Java中公开/私有函数都有 public/private等权限修饰，在Python/JavaScript中则没有私有函数，全部是公开函数，全靠程序员自觉的编程习惯。Solidity中默认的函数权限是Public，也就是完全公开。有时候这是不可取的。我们可以用 private 来修饰这些函数，例如下方的代码所示。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint</span><span class="p">[]</span> <span class="n">digits</span><span class="p">;</span>

<span class="kd">function</span> <span class="n">_addToArray</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_number</span><span class="p">)</span> <span class="k">private</span> <span class="p">{</span><span class="c1">//修饰符在最后</span>
  <span class="n">digits</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">_number</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这样该函数仅在本合约内可以被调用，并不会被外界感知或者调用到。我们通常约定俗成地将private修饰的函数名字前缀加上下划线 _ 来提醒程序员这里是私有函数。</p>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请将我们的下属函数修改为private修饰的函数，注意createCar已经有下划线前缀：</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="n">Car</span><span class="p">[]</span> <span class="k">public</span> <span class="n">cars</span><span class="p">;</span>
<span class="kd">function</span> <span class="n">_createCar</span><span class="p">(</span><span class="kt">string</span> <span class="n">_name</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_color</span><span class="p">)</span> <span class="n">_______</span> <span class="p">{</span>
   <span class="n">cars</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_color</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>除了函数 private/public 修饰符以外，还有相应的 internal/external 修饰符，internal 修饰符可以让合约继承后子合约访问该函数；external 修饰符让该函数只能被外部调用者调用。</p>
<p>一个有用的函数，还应该将处理结果返回给调用者，例如下方的函数返回一个Person类型的返回值。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;John&quot;</span><span class="p">;</span>

<span class="kd">function</span> <span class="n">makePerson</span> <span class="p">(</span><span class="kt">uint16</span> <span class="n">_age</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span><span class="c1">//注意使用了小括号</span>
  <span class="k">return</span> <span class="n">Person</span><span class="p">(</span><span class="n">_age</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里Person 两边使用了小括号，这点尤其有意思。其实返回值也可以是两个或以上的值，这和Python的语法相似，灵活性较Java/JavaScript有所提升，我们后文会提及。
Solidity的函数也有修饰符，称为modifiers，这标明了函数可能对区块链状态有无修改/读取的标记。一般都会标记该值让编译器帮我们执行代码的优化。例如下面两段代码。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="n">Person</span><span class="p">[]</span> <span class="k">public</span> <span class="n">people</span><span class="p">;</span>
<span class="kd">function</span> <span class="n">viewMe</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">people</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">// 读取了区块链数据区的people</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="n">_multiply</span><span class="p">(</span><span class="kt">uint</span> <span class="n">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">b</span><span class="p">)</span> <span class="k">private</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 未读取任何区块链数据， 单纯的计算</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里我们看见了两个修饰符，一个是view标明单纯的“查勘”类型的函数，它会读取记录在区块链上的数据，但它并不修改数据，是个只读操作。一个是pure标明是一个纯粹的函数，它和区块链上的数据无关，仅仅进行某种内存中的运算而已。那么读者会问，不标记任何修饰符的函数呢？那通常默认就是对区块数据会进行写操作的函数了。</p>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请创建一个函数 _generateRandomColor，并且该函数是私有的，仅读取区块链数据的，并且返回 uint 类型的值作为返回值。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">_generateRandomColor</span> <span class="p">(</span><span class="kt">string</span> <span class="n">_str</span><span class="p">)</span> <span class="n">_____</span> <span class="n">_____</span> <span class="k">returns</span> <span class="p">(</span><span class="n">_____</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
<p>请创建一个函数 divideNumbers，并且该函数是公开的，不读取/修改区块链数据的，并且返回 uint 类型的值作为返回值。</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">divideNumbers</span><span class="p">(</span><span class="kt">uint</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_b</span><span class="p">)</span> <span class="n">_____</span> <span class="n">_____</span> <span class="k">returns</span> <span class="p">(</span><span class="n">_____</span><span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h2>类型转换与内置函数<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>和面向对象的语言一样，Solidity包含了类型转换，它并不会帮你进行向下的类型转换操作，例如如下的操作会导致错误。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">uint</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="c1">// uint(uint256)类型太大了，无法塞入 uint8保存</span>
<span class="kt">uint8</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
<span class="c1">// 但是强制类型转换后就可以了</span>
<span class="kt">uint8</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="kt">uint8</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>在 Solidity 编程中有数个常用函数是内置送给开发者使用的，就和Python/JavaScript 中环境自带的函数一样，其中一个函数经常用到，就是keccak256哈希函数，这是我们前文经常提到的一个散列函数算法，可以根据任意长度的明文产生固定长度256位的哈希值。256位又正好和 uint 的位数相对应。例如：</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="nf">keccak256</span><span class="p">(</span><span class="s">&quot;aaaab&quot;</span><span class="p">);</span>
<span class="c1">//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5</span>
</pre></div>
</div>
<p>有了这工具，我们可以轻松地根据输入来生成一个“伪随机”的256位值。这里 keccack256函数并不是一个很好的随机源，因为它对固定输入产生的输出相同。好的随机源一般包含了操作系统里的噪音。在区块链上产生一个随机数是困难的，因为区块链每一步都讲究可验证，那么每次运行程序的结果应该相同：这意味着每次运行随机函数的输出亦应该一致。</p>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>请将下列函数填充完整，输入_str 后该函数将会填充如 keccack 函数进行哈希，并生成一个256位的哈希值，请强制转换它为256位的 uint 并和 colorModulus 作取余操作。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">_generateRandomColor</span><span class="p">(</span><span class="kt">string</span> <span class="n">_str</span><span class="p">)</span> <span class="k">private</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">rand</span> <span class="o">=</span> <span class="n">____</span><span class="p">(</span><span class="nf">keccak256</span><span class="p">(</span><span class="n">_str</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">rand</span> <span class="o">%</span> <span class="n">____</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请再创建一个函数 createRandomCar 该函数将接受一个车名 _name 作为输入值。该函数没有任何返回值，并且调用_generateRandomColor 产生汽车的颜色。之后调用 _createCar 函数（前文已经提及）将新产生的车子推入区块链数据中永久存储。</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="n">__________</span><span class="p">(</span><span class="kt">string</span> <span class="n">_name</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="n">randColor</span> <span class="o">=</span> <span class="n">_________</span><span class="p">(</span><span class="n">_name</span><span class="p">);</span>
    <span class="n">_______</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">randColor</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id8">
<h2>合约与事件<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>在前述以太坊虚拟机章节，我们讲过虚拟机的输出仅仅包含了两种手段：修改合约的区块链数据区域，或者产生日志输出。日志输出的内容组成部分就包含了“事件”。熟悉编程的读者肯定知道，日志产生后可以经常被其他程序读取，作为事后分析，或者某状态快照的参考信息。例如以太坊上对某些智能合约数据修改后，往往会主动产生日志记录下来，方便日后查询。下方的emit关键字代表了一次日志的产生。</p>
<div class="highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="kd">event</span> <span class="n">PersonCreated</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">uint16</span> <span class="n">age</span><span class="p">);</span>

<span class="kd">function</span> <span class="n">create</span><span class="p">(</span><span class="kt">string</span> <span class="n">_name</span><span class="p">,</span> <span class="kt">uint16</span> <span class="n">_age</span><span class="p">){</span>
    <span class="k">emit</span> <span class="n">PersonCreated</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_age</span><span class="p">);</span><span class="c1">// 直接产生了日志</span>
    <span class="k">return</span> <span class="n">Person</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里值得注意的是，日志的产生一定要用emit关键字，这在新版的语法里面是强调的。虚拟机收集了日志之后会妥善存储，并不用编程人员操心日志的去处。日志的收集往往会被前端调用该合约的程序所捕获，并且相应地展示出来UI结果。现在市面上的以太坊轻钱包都是根据日志整理出用户的各种代币余额的，日志极大地简化了前端开发中“遍历”区块链的负担。</p>
<div class="admonition- admonition">
<p class="first admonition-title">小练习</p>
<p>我们的CarFactory.sol合约接近完成了，请填充下面空白处，让合约能够产生NewCar事件，并且改造_createCar 函数让每辆车进入区块链数据区保存后能产生事件，通知外界区块链数据的变化。</p>
<div class="last highlight-solidity notranslate"><div class="highlight"><pre><span></span><span class="k">pragma solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">24</span><span class="p">;</span>

<span class="kd">contract</span> <span class="n">CarFactory</span> <span class="p">{</span>

    <span class="kd">event</span> <span class="n">_______</span><span class="p">(</span><span class="kt">uint</span> <span class="n">carId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">color</span><span class="p">);</span><span class="c1">// 填充此处</span>

    <span class="kt">uint</span> <span class="n">colorDigits</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="n">colorModulus</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">colorDigits</span><span class="p">;</span>

    <span class="kd">struct</span> <span class="n">Car</span> <span class="p">{</span>
        <span class="kt">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="n">color</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Color</span><span class="p">[]</span> <span class="k">public</span> <span class="n">cars</span><span class="p">;</span>

    <span class="kd">function</span> <span class="n">_createCar</span><span class="p">(</span><span class="kt">string</span> <span class="n">_name</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">_color</span><span class="p">)</span> <span class="k">private</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">id</span> <span class="o">=</span> <span class="n">cars</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">Car</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_color</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">emit</span> <span class="n">_______</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">_name</span><span class="p">,</span> <span class="n">_dna</span><span class="p">);</span> <span class="c1">// 填充此处</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">_generateRandomColor</span><span class="p">(</span><span class="kt">string</span> <span class="n">_str</span><span class="p">)</span> <span class="k">private</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">rand</span> <span class="o">=</span> <span class="kt">uint</span><span class="p">(</span><span class="nf">keccak256</span><span class="p">(</span><span class="n">_str</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">rand</span> <span class="o">%</span> <span class="n">colorModulus</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="n">createRandomCar</span><span class="p">(</span><span class="kt">string</span> <span class="n">_name</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="n">randColor</span> <span class="o">=</span> <span class="n">_generateRandomColor</span><span class="p">(</span><span class="n">_name</span><span class="p">);</span>
        <span class="n">_createCar</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">randColor</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="levelup.html" class="btn btn-neutral float-right" title="语法进阶" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="第 8 章 Solidity语法练习" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, laalaguer.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-142187300-2', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>